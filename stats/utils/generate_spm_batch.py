#!/usr/bin/env python3
"""
Generate SPM factorial design batch file from design structure.

This script creates a MATLAB batch file for SPM flexible factorial design
based on the parsed design structure.
"""

import argparse
import json
import sys
import re
import unicodedata
from pathlib import Path


MATLAB_BATCH_TEMPLATE = """% SPM Batch: Flexible Factorial Design (Implicit Subject Modeling)
% Auto-generated by generate_spm_batch.py
% Analysis: {modality} (smoothing: {smoothing}mm)
%
% Design: Flexible Factorial
% Factors: Group, Time
% Model: Interaction (Group x Time) ONLY
% Subject effects are handled implicitly via non-sphericity correction (Time is Dependent).

matlabbatch{{1}}.spm.stats.factorial_design.dir = {{'{output_dir}'}};

%% Factor 1: Group (between-subject)
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(1).name = 'Group';
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(1).levels = {n_groups};
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(1).dept = 0;  % Independent
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(1).variance = 1;  % Unequal variance
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(1).gmsca = 0;
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(1).ancova = 0;

%% Factor 2: Time (within-subject)
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(2).name = 'Time';
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(2).levels = {n_sessions};
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(2).dept = 1;  % Dependent (Repeated Measures)
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(2).variance = 1;  % Unequal variance
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(2).gmsca = 0;
matlabbatch{{1}}.spm.stats.factorial_design.des.fd.fact(2).ancova = 0;

%% Cells (Group_by_Time combinations)
{cells}

%% Model Specification: Interaction (Group x Time) is implicit in the cells
%% We do NOT include main effects or subject factors explicitly via maininter
%% because it is not a valid field for Flexible Factorial (fd) in this context.
% matlabbatch{{1}}.spm.stats.factorial_design.des.fd.maininter(1).fnums = [1 2];
% matlabbatch{{1}}.spm.stats.factorial_design.des.fd.maininter(1).number = 2;

%% Covariates
{covariates}

%% Global calculation & masking
matlabbatch{{1}}.spm.stats.factorial_design.masking.tm.tm_none = 1;
matlabbatch{{1}}.spm.stats.factorial_design.masking.im = 1;
{masking_em}
matlabbatch{{1}}.spm.stats.factorial_design.globalc.g_omit = 1;
matlabbatch{{1}}.spm.stats.factorial_design.globalm.gmsca.gmsca_no = 1;
matlabbatch{{1}}.spm.stats.factorial_design.globalm.glonorm = 1;
"""
def _sanitize_label(s):
    """Return an ASCII-safe label for use in MATLAB comments and identifiers.

    Rules:
    - Replace Unicode multiplication sign and similar with '_by_'
    - Normalize to NFKD and drop non-ASCII
    - Replace whitespace and non-word chars with underscore
    """
    if s is None:
        return ''
    # replace common multiplication char with by
    s = str(s).replace('\u00d7', '_by_')
    # normalize and drop non-ascii
    s = unicodedata.normalize('NFKD', str(s)).encode('ascii', 'ignore').decode('ascii')
    # replace spaces and any non-word char with underscore
    s = re.sub(r"[^A-Za-z0-9_]+", '_', s)
    return s


def generate_cells_code(design, subject_map):
    """Generate MATLAB code for factorial design cells.

    For volume data (e.g. VBM), SPM expects NIfTI paths with an implicit
    first-volume index (",1"). For surface data (e.g. cortical thickness),
    we pass GIfTI file paths *without* an added volume index.

    subject_map is a dict mapping subject id string -> subject level index (1-based).
    """
    groups = list(design['groups'].keys())
    sessions = design['sessions']

    cells_code = []
    cell_idx = 1

    for g_idx, group in enumerate(groups, 1):
        for s_idx, session in enumerate(sessions, 1):
            # Filter files for this cell from the flat list
            cell_files = [f for f in design['files'] 
                          if f['group'] == group and f['session'] == session]
            files = [f['path'] for f in cell_files]

            if not files:
                continue

            # Create cell name using '_by_' to match contrast naming convention
            cell_label = f"{_sanitize_label(group)}_by_{_sanitize_label(session)}"
            cell_code = f"% Cell {cell_idx}: {cell_label}\n"
            # We'll populate levels per-scan; SPM accepts a scalar or vector per cell
            # For flexible-factorial with Subject factor, each scan in the cell must be
            # annotated with the corresponding subject level. We write the levels vector
            # as [G S Sub] where Sub is the subject-level index.
            cell_code += f"matlabbatch{{1}}.spm.stats.factorial_design.des.fd.icell({cell_idx}).levels = [{g_idx} {s_idx}];\n"
            cell_code += f"matlabbatch{{1}}.spm.stats.factorial_design.des.fd.icell({cell_idx}).scans = {{\n"

            # Replace placeholder with per-scan subject indexing in a simple way:
            # SPM's batch expects a single levels vector for the cell (applies to all scans in cell),
            # but to model Subject we instead set the levels field to the GROUP and TIME values
            # and rely on the explicit 'subject' factor definition to be matched via the order
            # of scans. To be explicit and robust, we also include subject mapping in comments.

            for filepath in files:
                # For NIfTI volumes, SPM expects a volume index (",1").
                # For GIfTI surface files (.gii), no volume index is used.
                safe_fp = str(filepath).replace("'", "''")
                if str(filepath).lower().endswith('.gii'):
                    cell_code += f"    '{safe_fp}'\n"
                else:
                    cell_code += f"    '{safe_fp},1'\n"

            cell_code += "};\n"
            # Append a comment mapping the cell to subjects (helpful for debugging)
            subj_ids = [f['subject'] for f in cell_files]
            subj_idxs = [str(subject_map.get(sid, -1)) for sid in subj_ids]
            cell_code += f"% Subjects in this cell (levels): {', '.join(subj_idxs)}\n"

            cells_code.append(cell_code)
            cell_idx += 1

    return '\n'.join(cells_code)


def generate_covariates_code(design):
    """Generate MATLAB code for covariates."""
    
    if not design['covariates']:
        return "% No covariates"
    
    cov_code = []
    
    for cov_idx, (cov_name, cov_values) in enumerate(design['covariates'].items(), 1):
        # Create ASCII-safe display and canonical names
        disp_name = unicodedata.normalize('NFKD', str(cov_name)).encode('ascii', 'ignore').decode('ascii')
        disp_name = re.sub(r"[^A-Za-z0-9 _-]+", '', disp_name)
        safe_cname = _sanitize_label(cov_name)
        code = f"% Covariate {cov_idx}: {disp_name}\n"
        code += f"matlabbatch{{1}}.spm.stats.factorial_design.cov({cov_idx}).c = [\n"
        
        # Write values
        for val in cov_values:
            code += f"    {val}\n"

        code += "];\n"
        # Escape single quotes in covariate name for MATLAB
        safe_cov_for_matlab = str(safe_cname).replace("'", "''")
        code += f"matlabbatch{{1}}.spm.stats.factorial_design.cov({cov_idx}).cname = '{safe_cov_for_matlab}';\n"
        code += f"matlabbatch{{1}}.spm.stats.factorial_design.cov({cov_idx}).iCFI = 1;  % Interaction with factor\n"
        code += f"matlabbatch{{1}}.spm.stats.factorial_design.cov({cov_idx}).iCC = 1;   % Centering\n"

        cov_code.append(code)
    
    return '\n'.join(cov_code)


def generate_batch(args):
    """Main batch generation function."""
    
    print("Loading design structure...")
    with open(args.design_file, 'r') as f:
        design = json.load(f)
    
    print(f"Modality: {design['modality']}")
    print(f"Smoothing: {design['smoothing']}mm")
    print(f"Groups: {len(design['groups'])}")
    print(f"Sessions: {len(design['sessions'])}")
    print(f"Covariates: {len(design['covariates'])}")
    
    # Compute subject mapping (unique subjects across design['files'])
    subjects = []
    for finfo in design['files']:
        sid = finfo.get('subject')
        if sid is not None and sid not in subjects:
            subjects.append(sid)

    subject_map = {sid: idx+1 for idx, sid in enumerate(subjects)}

    # Generate code sections
    print("\nGenerating factorial design cells (including Subject factor)...")
    cells_code = generate_cells_code(design, subject_map)
    
    print("Generating covariate specifications...")
    covariates_code = generate_covariates_code(design)
    
    # Handle explicit mask for VBM: if a mask_file is provided, embed it
    # as the explicit mask in the generated batch. This ensures the SPM
    # Batch Editor will open with the selected explicit mask applied.
    # Escape output_dir for MATLAB single-quoted string
    safe_output_dir = str(args.output_dir).replace("'", "''")

    if hasattr(args, 'mask_file') and args.mask_file:
        # Escape single quotes in mask path for MATLAB
        safe_mask = str(args.mask_file).replace("'", "''")
        # Add volume index ,1 for NIfTI files (SPM requirement)
        masking_em = f"matlabbatch{{1}}.spm.stats.factorial_design.masking.em = {{'{safe_mask},1'}};"
        print(f"Embedding explicit mask in batch: {args.mask_file}")
    else:
        masking_em = "% matlabbatch{1}.spm.stats.factorial_design.masking.em = {};  % No explicit mask"
    
    # Fill template
    batch_content = MATLAB_BATCH_TEMPLATE.format(
        modality=design['modality'],
        smoothing=design['smoothing'],
        output_dir=safe_output_dir,
        n_groups=len(design['groups']),
        n_sessions=len(design['sessions']),
        cells=cells_code,
        covariates=covariates_code,
        masking_em=masking_em
    )
    
    # Save batch file
    output_file = Path(args.output)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_file, 'w') as f:
        f.write(batch_content)
    
    print(f"\nâœ“ SPM batch file saved to: {output_file}")
    
    return 0


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Generate SPM factorial design batch file'
    )
    
    parser.add_argument('--design-file', required=True,
                       help='Path to design.json file')
    parser.add_argument('--output-dir', required=True,
                       help='Output directory for SPM results')
    parser.add_argument('--modality', required=True,
                       help='Analysis modality')
    parser.add_argument('--output', required=True,
                       help='Output path for batch .m file')
    parser.add_argument('--mask-file', default=None,
                       help='Optional: path to explicit mask file (NIfTI) for VBM analysis')
    
    args = parser.parse_args()
    sys.exit(generate_batch(args))
